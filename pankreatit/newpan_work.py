# -*- coding: utf-8 -*-
"""pan_work.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1DXMjsC5n_tEGkU3M01uairLBhxXIFH0o
"""

import joblib
import pandas as pd
import seaborn as sns
from matplotlib import pyplot as plt
from sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier, VotingClassifier, AdaBoostClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.model_selection import cross_validate, GridSearchCV
from sklearn.neighbors import KNeighborsClassifier
from sklearn.svm import SVC
from sklearn.tree import DecisionTreeClassifier
from sklearn.preprocessing import StandardScaler
from sklearn.preprocessing import RobustScaler
from sklearn.metrics import accuracy_score, roc_auc_score, confusion_matrix, classification_report, plot_roc_curve
from sklearn.model_selection import train_test_split, cross_validate
from scipy import stats
import numpy as np
from sklearn.preprocessing import MinMaxScaler
from sklearn.cluster import KMeans
from scipy.cluster.hierarchy import dendrogram
from scipy.cluster.hierarchy import linkage
from yellowbrick.cluster import KElbowVisualizer
from sklearn.cluster import AgglomerativeClustering
from sklearn.preprocessing import LabelEncoder
from xgboost import XGBClassifier
from lightgbm import LGBMClassifier

pd.set_option('display.max_columns', 50)
pd.set_option('display.width', 500)
pd.set_option('display.max_rows', 300)
import warnings
warnings.filterwarnings("ignore")

def outlier_thresholds(dataframe, col_name, q1=0.25, q3=0.75):
    quartile1 = dataframe[col_name].quantile(q1)
    quartile3 = dataframe[col_name].quantile(q3)
    interquantile_range = quartile3 - quartile1
    up_limit = quartile3 + 1.5 * interquantile_range
    low_limit = quartile1 - 1.5 * interquantile_range
    return low_limit, up_limit

def check_outlier(dataframe, col_name, q1=0.25, q3=0.75):
    low_limit, up_limit = outlier_thresholds(dataframe, col_name, q1, q3)
    if dataframe[(dataframe[col_name] > up_limit) | (dataframe[col_name] < low_limit)].any(axis=None):
        return True
    else:
        return False

def replace_with_thresholds(dataframe, variable):
    low_limit, up_limit = outlier_thresholds(dataframe, variable)
    dataframe.loc[(dataframe[variable] < low_limit), variable] = low_limit
    dataframe.loc[(dataframe[variable] > up_limit), variable] = up_limit

def high_correlated_cols(dataframe, plot=False, corr_th=0.60):
    corr = dataframe.corr()
    cor_matrix = corr.abs()
    upper_triangle_matrix = cor_matrix.where(np.triu(np.ones(cor_matrix.shape), k=1).astype(np.bool))
    drop_list = [col for col in upper_triangle_matrix.columns if any(upper_triangle_matrix[col] > corr_th)]
    if plot:
        import seaborn as sns
        import matplotlib.pyplot as plt
        sns.set(rc={'figure.figsize': (15, 15)})
        sns.heatmap(corr, cmap="RdBu")
        plt.show()
    return drop_list

df=pd.read_excel("pankreatit/newpan.xlsx")

df.drop([254,255,256,257,258,259,260],axis=0, inplace=True)

df["dep_var"] = df["DEATH"] + df["ICU"] +df["RADIO"]
df["dep_var"].value_counts()
df.dep_var[df["dep_var"]>=1] = 1
df['LDH'] = df['LDH'].fillna(df['LDH'].median())
df['CRP'] = df['CRP'].fillna(df['LDH'].median())
df['PCT'] = df['PCT'].fillna(df['PCT'].median())
df['PDW'] = df['PDW'].fillna(df['PDW'].median())
df['PLCR'] = df['PLCR'].fillna(df['PLCR'].median())
df['NBRC_per'] = df['NBRC_per'].fillna(df['NBRC_per'].median())
df['NBRC'] = df['NBRC'].fillna(df['NBRC'].median())
df['UREA'] = df['UREA'].fillna(df['UREA'].median())
df["UREA"]=df["UREA"].astype(float)

df.drop(["NBRC","NBRC_per"],axis=1, inplace=True)
df.drop(["AML/NEU","LIP/NEU","PLCR","RDW_SD","RDW_CV","PCT","PDW"],axis=1, inplace=True)

num_cols = [col for col in df.columns if df[col].dtypes != "O"]
cat_cols = [col for col in df.columns if df[col].dtypes == "O"]

for col in num_cols:
     print(col, check_outlier(df, col))

replace_with_thresholds(df,"NEU")
replace_with_thresholds(df,"WBC")
replace_with_thresholds(df,"LYM")
replace_with_thresholds(df,"SII")
replace_with_thresholds(df,"UREA")
replace_with_thresholds(df,"CREA")
replace_with_thresholds(df,"AST")
replace_with_thresholds(df,"ALT")
replace_with_thresholds(df,"LDH")
replace_with_thresholds(df,"NEU*PLT")
replace_with_thresholds(df,"HGB")
replace_with_thresholds(df,"PLT")
replace_with_thresholds(df,"GLU")
replace_with_thresholds(df,"AMYLASE")
replace_with_thresholds(df,"LIPASE")
replace_with_thresholds(df,"PLR")
replace_with_thresholds(df,"NLR")

df["dep_var"].value_counts()

df["RADIO_SCORE"]=df["RADIO"]+1

df["RADIO_SCORE"]=df["RADIO_SCORE"]*df["AGE"]

df.drop(["GALLSTONE","RADIO"],axis=1, inplace=True)

df.head()

"""------------------------FEU-ENG----------------------------------------------------------------------------------------------"""

high_correlated_cols(df, plot=True)

corr = df[num_cols].corr()

corr

df["NEW_AMY_LIP"]=df["AMYLASE"]+df["LIPASE"]

df["NEW_WBC_EQL"]=df["WBC"]-df["NEU"]-df["LYM"]

df["NEW_AMY_UREA"]=df["UREA"]/df["AMYLASE"]

df["NEW_AMY_CREA"]=df["AMYLASE"]/df["CREA"]

list = ["DEATH","ICU","dep_var"]

new_list = [col for col in df.columns if col not in list]

X = df[new_list]
y = df["dep_var"]

"""--------------------------ÖNCELİKLE LOGISTIC DENENİYOR VE CONFUSION MATRIX TE DOĞRULANIUYOR-----------------------------------------------"""

log_model = LogisticRegression().fit(X, y)

log_model.intercept_
log_model.coef_

y_pred = log_model.predict(X)

y_pred[0:10]

y[0:10]

def plot_confusion_matrix(y, y_pred):
    acc = round(accuracy_score(y, y_pred), 2)
    cm = confusion_matrix(y, y_pred)
    sns.heatmap(cm, annot=True, fmt=".0f")
    plt.xlabel('y_pred')
    plt.ylabel('y')
    plt.title('Accuracy Score: {0}'.format(acc), size=10)
    plt.show()

plot_confusion_matrix(y, y_pred)

print(classification_report(y, y_pred))

y_prob = log_model.predict_proba(X)[:, 1]
roc_auc_score(y, y_prob)

X_train, X_test, y_train, y_test = train_test_split(X,
                                                    y,
                                                    test_size=0.20, stratify=y, random_state=45)

log_model = LogisticRegression().fit(X_train, y_train)

y_pred = log_model.predict(X_test)
y_prob = log_model.predict_proba(X_test)[:, 1]

print(classification_report(y_test, y_pred))

plot_roc_curve(log_model, X_test, y_test)
plt.title('ROC Curve')
plt.plot([0, 1], [0, 1], 'r--')
plt.show()

roc_auc_score(y_test, y_prob)

X = df[new_list]
y = df["dep_var"]

log_model = LogisticRegression().fit(X, y)

cv_results = cross_validate(log_model,
                            X, y,
                            cv=10,
                            scoring=["accuracy", "precision", "recall", "f1", "roc_auc"])

cv_results['test_accuracy'].mean()

cv_results['test_precision'].mean()

cv_results['test_recall'].mean()

cv_results['test_f1'].mean()

cv_results['test_roc_auc'].mean()









"""random prediction"""

X.columns

random_user = X.sample(1, random_state=45)
log_model.predict(random_user)
rand2 = np.array([38,1.0,81.0,12.9,11.44,0.96,10.9,132.0,1510.08,1573.0,111.0,36.4,0.61,43.0,25.0,229.0,2615.0,3225.0,2.53,137.0,11.0,81.0,5840.0,0.5,0.01392,4286.885246][38,1.0,81.0,12.9,11.44,0.96,10.9,132.0,1510.08,1573.0,111.0,36.4,0.61,43.0,25.0,229.0,2615.0,3225.0,2.53,137.0,11.0,81.0,5840.0,0.5,0.01392,4286.885246])
len(rand2)
random_user.shape
a= pd.DataFrame(columns=['SEX', 'AGE', 'WBC', 'NEU', 'LYM', 'HGB', 'PLT', 'NEU*PLT', 'SII', 'GLU', 'UREA', 'CREA', 'AST', 'ALT', 'LDH', 'AMYLASE', 'LIPASE', 'CRP', 'PLR', 'NLR', 'RADIO_SCORE', 'NEW_AMY_LIP', 'NEW_WBC_EQL', 'NEW_AMY_UREA', 'NEW_AMY_CREA'],data=[[1.0,81.0,12.9,11.44,0.96,10.9,132.0,1510.08,1573.0,111.0,36.4,0.61,43.0,25.0,229.0,2615.0,3225.0,2.53,137.0,11.0,81.0,5840.0,0.5,0.01392,4286.885246]])
random_user.columns
log_model.predict(a)

import pickle
pickle.dump(log_model,open("model.pk1","wb"))
log_model = pickle.load(open("model.pk1","rb"))
print(log_model.predict(random_user))

import numpy as np
import pandas as pd
import pickle
log_model = pickle.load(open("model.pk1","rb"))
a= pd.DataFrame(columns=['SEX', 'AGE', 'WBC', 'NEU', 'LYM',
                         'HGB', 'PLT', 'NEU*PLT', 'SII', 'GLU',
                         'UREA', 'CREA', 'AST', 'ALT', 'LDH',
                         'AMYLASE', 'LIPASE', 'CRP', 'PLR', 'NLR',
                         'RADIO_SCORE', 'NEW_AMY_LIP', 'NEW_WBC_EQL',
                         'NEW_AMY_UREA', 'NEW_AMY_CREA'],
                data=[[1.0,81.0,12.9,11.44,0.96,10.9,132.0,
                       1510.08,1573.0,111.0,36.4,0.61,43.0,25.0,
                       229.0,2615.0,3225.0,2.53,137.0,11.0,81.0,
                       5840.0,0.5,0.01392,4286.885246]])


output = log_model.predict(a)
output[0]
list = [1.0,81.0,12.9,11.44,0.96,10.9,132.0,
                       1510.08,1573.0,111.0,36.4,0.61,43.0,25.0,
                       229.0,2615.0,3225.0,2.53,137.0,11.0,81.0,
                       5840.0,0.5,0.01392,4286.885246]
b = [np.array(list)]
c = pd.DataFrame(data=b,columns=['SEX', 'AGE', 'WBC', 'NEU', 'LYM',
                         'HGB', 'PLT', 'NEU*PLT', 'SII', 'GLU',
                         'UREA', 'CREA', 'AST', 'ALT', 'LDH',
                         'AMYLASE', 'LIPASE', 'CRP', 'PLR', 'NLR',
                         'RADIO_SCORE', 'NEW_AMY_LIP', 'NEW_WBC_EQL',
                         'NEW_AMY_UREA', 'NEW_AMY_CREA'])
log_model.predict(c)